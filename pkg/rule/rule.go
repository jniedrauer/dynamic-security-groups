package rule

import (
	"log"
	"net"
	"strings"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/ec2"
	"github.com/aws/aws-sdk-go/service/ec2/ec2iface"
)

// DescriptionPrefix is the description to attach to a security group rule.
const DescriptionPrefix = "AUTOGENERATED: "

// CIDRSuffix is the netmask for a single IP address.
const CIDRSuffix = "/32"

// Protocol constants
const (
	ProtocolTCP = "tcp"
	ProtocolUDP = "udp"
	ProtoclICMP = "icmp"
)

// Rule is one or more security group rules for a host.
type Rule struct {
	// Name is the FQDN.
	Name string `json:"name"`

	// Port is the port to allow traffic to.
	Port int `json:"port"`

	// Protocol is the network protocol.
	Protocol string `json:"protocol"`

	// Egress specifies whether the rule is ingress (default) or egress.
	Egress bool `json:"egress"`

	// CIDRs is populated with the resolved FQDN.
	CIDRs []string
}

// Resolve resolves the rule's name to IP addresses.
func (r *Rule) Resolve() ([]string, error) {
	if len(r.CIDRs) > 0 {
		return r.CIDRs, nil
	}

	ips, err := net.LookupHost(r.Name)
	if err != nil {
		return nil, err
	}

	cidrs := make([]string, len(ips))
	for i := range ips {
		cidrs[i] = ips[i] + CIDRSuffix
	}

	return cidrs, nil
}

// Exists returns a boolean for whether or not a given IP address in a rule
// already exists in a security group.
func Exists(ip string, rule Rule, sg *ec2.SecurityGroup) bool {
	var oldRules []*ec2.IpPermission
	if rule.Egress {
		oldRules = sg.IpPermissionsEgress
	} else {
		oldRules = sg.IpPermissions
	}

	for _, oldRule := range oldRules {
		if oldRule.FromPort == nil || oldRule.ToPort == nil {
			continue
		}
		if int(*oldRule.FromPort) != rule.Port || int(*oldRule.ToPort) != rule.Port {
			continue
		}

		if oldRule.IpProtocol == nil || *oldRule.IpProtocol != rule.Protocol {
			continue
		}

		for _, oldCIDR := range oldRule.IpRanges {
			if oldCIDR.CidrIp != nil && *oldCIDR.CidrIp == ip {
				return true
			}
		}
	}

	return false
}

// Add adds ingress and egress rules to a security group.
func Add(rules []Rule, sg *ec2.SecurityGroup, ec2Client ec2iface.EC2API) error {
	egress := &ec2.AuthorizeSecurityGroupEgressInput{
		GroupId:       sg.GroupId,
		IpPermissions: []*ec2.IpPermission{},
	}

	ingress := &ec2.AuthorizeSecurityGroupIngressInput{
		GroupId:       sg.GroupId,
		IpPermissions: []*ec2.IpPermission{},
	}

	for _, rule := range rules {
		cidrs, err := rule.Resolve()
		if err != nil {
			return nil
		}

		log.Printf("Resolved %s to %+v", rule.Name, cidrs)

		ipRanges := make([]*ec2.IpRange, 0)
		for _, cidr := range cidrs {
			if Exists(cidr, rule, sg) {
				continue
			}

			ipRanges = append(ipRanges, &ec2.IpRange{
				CidrIp:      aws.String(cidr),
				Description: aws.String(DescriptionPrefix + rule.Name),
			})
		}

		if len(ipRanges) <= 0 {
			continue
		}

		if rule.Egress {
			egress.IpPermissions = append(egress.IpPermissions, &ec2.IpPermission{
				FromPort:   aws.Int64(int64(rule.Port)),
				IpProtocol: aws.String(rule.Protocol),
				IpRanges:   ipRanges,
				ToPort:     aws.Int64(int64(rule.Port)),
			})
		} else {
			ingress.IpPermissions = append(ingress.IpPermissions, &ec2.IpPermission{
				FromPort:   aws.Int64(int64(rule.Port)),
				IpProtocol: aws.String(rule.Protocol),
				IpRanges:   ipRanges,
				ToPort:     aws.Int64(int64(rule.Port)),
			})
		}
	}

	if len(egress.IpPermissions) > 0 {
		log.Printf("Adding %d egress rules", len(egress.IpPermissions))

		_, err := ec2Client.AuthorizeSecurityGroupEgress(egress)
		if err != nil {
			return err
		}
	} else {
		log.Print("No egress rules to add")
	}

	if len(ingress.IpPermissions) > 0 {
		log.Printf("Adding %d ingress rules", len(ingress.IpPermissions))

		_, err := ec2Client.AuthorizeSecurityGroupIngress(ingress)
		if err != nil {
			return err
		}
	} else {
		log.Print("No ingress rules to add")
	}

	return nil
}

// Cleanup removes rules from a security group which are *not* in the
// provided list of rules.
func Cleanup(rules []Rule, sg *ec2.SecurityGroup, ec2Client ec2iface.EC2API) error {
	egress := &ec2.RevokeSecurityGroupEgressInput{
		GroupId:       sg.GroupId,
		IpPermissions: []*ec2.IpPermission{},
	}

	ingress := &ec2.RevokeSecurityGroupIngressInput{
		GroupId:       sg.GroupId,
		IpPermissions: []*ec2.IpPermission{},
	}

EGRESS_OUTER:
	for _, oldRule := range sg.IpPermissionsEgress {
		for _, oldCIDR := range oldRule.IpRanges {
			if oldCIDR.Description == nil || !strings.HasPrefix(*oldCIDR.Description, DescriptionPrefix) {
				continue EGRESS_OUTER
			}

			for _, newRule := range rules {
				for _, cidr := range newRule.CIDRs {
					if oldCIDR.CidrIp != nil && *oldCIDR.CidrIp == cidr {
						continue EGRESS_OUTER
					}
				}
			}
		}

		egress.IpPermissions = append(egress.IpPermissions, oldRule)
	}

INGRESS_OUTER:
	for _, oldRule := range sg.IpPermissions {
		for _, oldCIDR := range oldRule.IpRanges {
			if oldCIDR.Description == nil || !strings.HasPrefix(*oldCIDR.Description, DescriptionPrefix) {
				continue INGRESS_OUTER
			}

			for _, newRule := range rules {
				for _, cidr := range newRule.CIDRs {
					if oldCIDR.CidrIp != nil && *oldCIDR.CidrIp == cidr {
						continue INGRESS_OUTER
					}
				}
			}
		}

		ingress.IpPermissions = append(ingress.IpPermissions, oldRule)
	}

	if len(egress.IpPermissions) > 0 {
		log.Printf("Removing %d egress rules", len(egress.IpPermissions))

		_, err := ec2Client.RevokeSecurityGroupEgress(egress)
		if err != nil {
			return err
		}
	} else {
		log.Print("No egress rules to remove")
	}

	if len(ingress.IpPermissions) > 0 {
		log.Printf("Removing %d ingress rules", len(ingress.IpPermissions))

		_, err := ec2Client.RevokeSecurityGroupIngress(ingress)
		if err != nil {
			return err
		}
	} else {
		log.Print("No ingress rules to remove")
	}

	return nil
}
